{
  "compare" : null,
  "previous_successful_build" : {
    "build_num" : 439,
    "status" : "success",
    "build_time_millis" : 42871
  },
  "build_parameters" : {
    "CIRCLE_JOB" : "emulate-dev_2"
  },
  "oss" : true,
  "all_commit_details_truncated" : false,
  "committer_date" : null,
  "steps" : [ {
    "name" : "Spin up Environment",
    "actions" : [ {
      "truncated" : false,
      "index" : 0,
      "parallel" : true,
      "failed" : null,
      "infrastructure_fail" : null,
      "name" : "Spin up Environment",
      "bash_command" : null,
      "status" : "success",
      "timedout" : null,
      "continue" : null,
      "end_time" : "2019-09-04T13:25:20.290Z",
      "type" : "test",
      "allocation_id" : "5d6fbb2721f01f5042ac2669-0-build/36256606",
      "output_url" : "https://circle-production-action-output.s3.amazonaws.com/a9451bdfb25a148a13bbf6d5-5d6693fd790dc1214f4a0bab-0-0?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20190904T132808Z&X-Amz-SignedHeaders=host&X-Amz-Expires=431999&X-Amz-Credential=AKIAIJNI6FA5RIAFFQ7Q%2F20190904%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=0cb018d8075a0dc30f8f414f29f3281ad9112406fe06fee304608969d4b9f058",
      "start_time" : "2019-09-04T13:25:05.028Z",
      "background" : false,
      "exit_code" : null,
      "insignificant" : false,
      "canceled" : null,
      "step" : 0,
      "run_time_millis" : 15262,
      "has_output" : true
    } ]
  }, {
    "name" : "echo \"This job serves to emulate a job in a workflow that takes some amount of time to complete.\"",
    "actions" : [ {
      "truncated" : false,
      "index" : 0,
      "parallel" : true,
      "failed" : null,
      "infrastructure_fail" : null,
      "name" : "echo \"This job serves to emulate a job in a workflow that takes some amount of time to complete.\"",
      "bash_command" : "#!/bin/bash -eo pipefail\necho \"This job serves to emulate a job in a workflow that takes some amount of time to complete.\"",
      "status" : "success",
      "timedout" : null,
      "continue" : null,
      "end_time" : "2019-09-04T13:25:20.589Z",
      "type" : "test",
      "allocation_id" : "5d6fbb2721f01f5042ac2669-0-build/36256606",
      "output_url" : "https://circle-production-action-output.s3.amazonaws.com/57551bdfb25a148a04bbf6d5-5d6693fd790dc1214f4a0bab-101-0?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20190904T132808Z&X-Amz-SignedHeaders=host&X-Amz-Expires=431999&X-Amz-Credential=AKIAIJNI6FA5RIAFFQ7Q%2F20190904%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=adf5faf4b837374eb9910690c43bff2a879be7e923f9e390c4168219c230e086",
      "start_time" : "2019-09-04T13:25:20.564Z",
      "background" : false,
      "exit_code" : 0,
      "insignificant" : false,
      "canceled" : null,
      "step" : 101,
      "run_time_millis" : 25,
      "has_output" : true
    } ]
  }, {
    "name" : "sleep 50",
    "actions" : [ {
      "truncated" : false,
      "index" : 0,
      "parallel" : true,
      "failed" : null,
      "infrastructure_fail" : null,
      "name" : "sleep 50",
      "bash_command" : "#!/bin/bash -eo pipefail\nsleep 50",
      "status" : "success",
      "timedout" : null,
      "continue" : null,
      "end_time" : "2019-09-04T13:26:10.601Z",
      "type" : "test",
      "allocation_id" : "5d6fbb2721f01f5042ac2669-0-build/36256606",
      "start_time" : "2019-09-04T13:25:20.594Z",
      "background" : false,
      "exit_code" : 0,
      "insignificant" : false,
      "canceled" : null,
      "step" : 102,
      "run_time_millis" : 50007,
      "has_output" : false
    } ]
  } ],
  "body" : null,
  "usage_queued_at" : "2019-09-04T13:24:55.771Z",
  "context_ids" : [ ],
  "fail_reason" : null,
  "retry_of" : null,
  "reponame" : "sumologic-orb",
  "ssh_users" : [ ],
  "build_url" : "https://circleci.com/gh/CircleCI-Public/sumologic-orb/444",
  "parallel" : 1,
  "failed" : false,
  "branch" : null,
  "username" : "CircleCI-Public",
  "author_date" : null,
  "why" : "github",
  "user" : {
    "is_user" : true,
    "login" : "KyleTryon",
    "avatar_url" : "https://avatars1.githubusercontent.com/u/33272306?v=4",
    "name" : "Kyle Tryon",
    "vcs_type" : "github",
    "id" : 33272306
  },
  "vcs_revision" : "9016223dff04170507e9f84e3cf2efb1738839a5",
  "workflows" : {
    "job_name" : "emulate-dev_2",
    "job_id" : "bb1d7ba6-2e9b-45e5-b390-f282afe492c2",
    "workflow_id" : "08b56956-7fe6-436c-ab3d-dfe3fe65ad1e",
    "workspace_id" : "08b56956-7fe6-436c-ab3d-dfe3fe65ad1e",
    "upstream_job_ids" : [ ],
    "upstream_concurrency_map" : { },
    "workflow_name" : "integration-tests_prod-release"
  },
  "owners" : [ "KyleTryon" ],
  "vcs_tag" : "integration-patch-Alpha-9016223",
  "pull_requests" : [ ],
  "build_num" : 444,
  "infrastructure_fail" : false,
  "committer_email" : null,
  "has_artifacts" : true,
  "previous" : {
    "build_num" : 439,
    "status" : "success",
    "build_time_millis" : 42871
  },
  "status" : "success",
  "committer_name" : null,
  "retries" : null,
  "subject" : null,
  "vcs_type" : "github",
  "timedout" : false,
  "dont_build" : null,
  "lifecycle" : "finished",
  "no_dependency_cache" : false,
  "stop_time" : "2019-09-04T13:26:10.643Z",
  "ssh_disabled" : true,
  "build_time_millis" : 65671,
  "picard" : {
    "build_agent" : {
      "image" : "circleci/picard:1.0.14060-707644a8",
      "properties" : {
        "build_agent" : "1.0.14060-707644a8",
        "executor" : "docker"
      }
    },
    "resource_class" : {
      "cpu" : 2.0,
      "ram" : 4096,
      "class" : "medium"
    },
    "executor" : "docker"
  },
  "circle_yml" : {
    "string" : "# Orb 'circleci/sumologic@dev:alpha' resolved to 'circleci/sumologic@dev:alpha'\n# Orb 'circleci/orb-tools@8.27.3' resolved to 'circleci/orb-tools@8.27.3'\nversion: 2\njobs:\n  orb-tools/pack:\n    docker:\n    - image: circleci/circleci-cli:latest\n    steps:\n    - checkout\n    - run:\n        command: |\n          mkdir -pv $(dirname orb.yml)\n        name: Ensure destination path\n    - run:\n        command: |\n          circleci config pack src > orb.yml\n        name: Pack src to orb.yml\n    - run:\n        command: circleci orb validate orb.yml\n        name: Validate whether this is a well-formed orb.\n    - persist_to_workspace:\n        paths:\n        - orb.yml\n        root: .\n    - store_artifacts:\n        path: orb.yml\n  dev-promote-major:\n    docker:\n    - image: circleci/circleci-cli:latest\n    steps:\n    - checkout\n    - run:\n        command: |\n          circleci orb publish promote \\\n            circleci/orb-tools@dev:${CIRCLE_SHA1:0:7} \\\n            major --token \\\n            $CIRCLE_TOKEN\n\n          echo \"View this orb release in the orb registry:\"\n          echo \"https://circleci.com/orbs/registry/orb/circleci/orb-tools\"\n        name: promote dev orb to production/semantic release\n    - add_ssh_keys:\n        fingerprints:\n        - 97:c9:c2:9e:1b:04:ee:ee:99:4d:6b:f7:ce:e0:00:78\n    - run:\n        command: |\n          git config --global user.email \"$CIRCLE_USERNAME@users.noreply.github.com\"\n          git config --global user.name \"$CIRCLE_USERNAME\"\n\n          # construct/push new tag\n          NEW_VERSION=$(circleci orb info circleci/orb-tools | grep Latest | sed -E 's|Latest: circleci/orb-tools@||')\n\n          TAG=\"v$NEW_VERSION\"\n\n          git tag -a \"$TAG\" \\\n            -m \"major\" \\\n            -m \"View this orb release in the orb registry:\" \\\n            -m \"https://circleci.com/orbs/registry/orb/circleci/orb-tools?version=$NEW_VERSION\" \\\n            -m \"View this orb release using the CircleCI CLI:\" \\\n            -m \"\\`circleci orb source circleci/orb-tools@$NEW_VERSION\\`\"\n\n          git push origin \"$TAG\"\n\n          # delete local tags\n          git tag -d $(git tag -l \"master*\")\n\n          # fetch remote tags\n          git fetch\n\n          # delete remote tag\n          git push origin --delete $(git tag -l git tag -l \"master*\") || true\n        name: git config\n  emulate-master_2:\n    docker:\n    - image: cimg/node\n    steps:\n    - run:\n        command: echo \"This job serves to emulate a job in a workflow that takes some\n          amount of time to complete.\"\n    - run:\n        command: sleep 50\n  emulate-master_1:\n    docker:\n    - image: cimg/node\n    steps:\n    - run:\n        command: echo \"This job serves to emulate a job in a workflow that takes some\n          amount of time to complete.\"\n    - run:\n        command: sleep 20\n  trigger-integration-master:\n    docker:\n    - image: cibuilds/base\n    resource_class: small\n    steps:\n    - checkout\n    - add_ssh_keys:\n        fingerprints:\n        - 97:c9:c2:9e:1b:04:ee:ee:99:4d:6b:f7:ce:e0:00:78\n    - run:\n        command: |\n          git config --global user.email \"$CIRCLE_USERNAME@users.noreply.github.com\"\n          git config --global user.name \"$CIRCLE_USERNAME\"\n        name: git config\n    - run:\n        command: \"if [[ -z \\\"${CIRCLE_TOKEN}\\\" ]]; then\\n  echo \\\"ERROR: Missing environment\\\n          \\ variable CIRCLE_TOKEN\\\" >&2\\n  if [[ -n \\\"You have not stored a CircleCI\\\n          \\ API token. If this is a private repository, the next step will fail.\\n\\\n          \\\" ]]; then\\n    echo \\\"You have not stored a CircleCI API token. If this\\\n          \\ is a private repository, the next step will fail.\\n\\\" >&2\\n  fi\\n  \\n\\\n          else\\n  echo \\\"Yes, CIRCLE_TOKEN is defined!\\\"\\nfi\\n\"\n        name: Checking if $CIRCLE_TOKEN is defined...\n    - run:\n        command: |\n          ## VARS\n\n          # this starts as false, set to true to exit `until` loop\n          FOUND_BASE_COMPARE_COMMIT=false\n\n          # start iteration from the job before $CIRCLE_BUILD_NUM\n          JOB_NUM=$(( $CIRCLE_BUILD_NUM - 1 ))\n\n          ## UTILS\n\n          extract_commit_from_job () {\n            # abstract this logic out, it gets reused a few times\n            # takes $1 (VCS_TYPE) & $2 (a job number)\n\n            curl --user $CIRCLE_TOKEN: \\\n              https://circleci.com/api/v1.1/project/$1/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$2 | \\\n              grep '\"vcs_revision\" : ' | sed -E 's/\"vcs_revision\" ://' | sed -E 's/[[:punct:]]//g' | sed -E 's/ //g'\n          }\n\n          check_if_branch_is_new () {\n            # takes a single argument for VCS_TYPE\n            # functionally, 'new' means: same commit for all jobs on the branch\n\n            # assume this is true, set to false if proven otherwise\n            local BRANCH_IS_NEW=true\n\n            # grab URL endpoints for jobs on this branch\n            # transform them into single-job API endpoints\n            # output them to a file for subsequent iteration\n            curl --user $CIRCLE_TOKEN: \\\n              https://circleci.com/api/v1.1/project/$1/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/tree/$CIRCLE_BRANCH?limit=100 | \\\n              grep \"\\\"build_url\\\" : \\\"http\" | sed -E 's/\"build_url\" : //' | \\\n              sed -E 's|/bb/|/api/v1.1/project/bitbucket/|' | \\\n              sed -E 's|/gh/|/api/v1.1/project/github/|' | \\\n              sed -E 's/\"|,//g' | sed -E 's/ //g' \\\n              > API_ENDPOINTS_FOR_JOBS_ON_BRANCH\n\n            # loop through each job to compare commit hashes\n            while read line\n            do\n              if [[ $(curl --user $CIRCLE_TOKEN: $line | grep \"\\\"vcs_revision\\\" : \\\"$CIRCLE_SHA1\\\"\") ]]; then\n                continue\n              else\n                BRANCH_IS_NEW=false\n                break\n              fi\n            done < API_ENDPOINTS_FOR_JOBS_ON_BRANCH\n\n            # clean up\n            if [[ false == false ]]; then\n              rm -f API_ENDPOINTS_FOR_JOBS_ON_BRANCH\n            fi\n\n            # true or false\n            echo $BRANCH_IS_NEW\n          }\n\n          ## SETUP\n\n          # determine VCS type, so we don't worry about it later\n          if [[ $(echo $CIRCLE_REPOSITORY_URL | grep github.com:$CIRCLE_PROJECT_USERNAME) ]]; then\n            VCS_TYPE=github\n          else\n            VCS_TYPE=bitbucket\n          fi\n\n          # check if this is a new branch, as that informs later steps\n          echo \"checking if $CIRCLE_BRANCH is a new branch...\"\n          echo \"----------------------------------------------------------------------------------------------------\"\n          if [[ $(check_if_branch_is_new $VCS_TYPE) == true ]]; then\n            echo \"----------------------------------------------------------------------------------------------------\"\n            echo \"yes, $CIRCLE_BRANCH is new and $CIRCLE_SHA1 is its only commit\"\n            echo \"finding most recent ancestor commit from any other branch...\"\n            echo \"----------------------------------------------------------------------------------------------------\"\n            BRANCH_IS_NEW=true\n          else\n            echo \"----------------------------------------------------------------------------------------------------\"\n            echo \"$CIRCLE_BRANCH is not a new branch, searching for its most recent previous commit...\"\n            echo \"----------------------------------------------------------------------------------------------------\"\n            BRANCH_IS_NEW=false\n          fi\n\n          ## EXECUTION\n\n          # manually iterate through previous jobs\n          until [[ $FOUND_BASE_COMPARE_COMMIT == true ]]\n          do\n\n            # save circle api output to a temp file for reuse\n            curl --user $CIRCLE_TOKEN: \\\n              https://circleci.com/api/v1.1/project/$VCS_TYPE/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUM \\\n              > JOB_OUTPUT\n\n            # general approach:\n            # there's a couple of skip conditions to observe here—\n            # roughly in order of precedence:\n\n            # 1. is JOB_NUM part of the current workflow?\n            # 2. is JOB_NUM a retry of a job from the same commit?\n              # 2.5 or part of a rerun workflow from the same commit?\n            # 3. is JOB_NUM from a different branch?\n              # 3.5 unless this is a new branch—see below\n\n            # edge cases:\n            # 1. if $CIRCLE_SHA1 is the first commit on a new branch\n              # then we need the most recent ancestor, branch-agnostic\n              # 1.5 a new branch doesn't always mean a new commit\n\n            # handling condition 3 & edge case 1:\n            # check if this is a brand-new branch\n            if [[ $BRANCH_IS_NEW == true ]]; then\n              COMMIT_FROM_JOB_NUM=$(extract_commit_from_job $VCS_TYPE $JOB_NUM)\n\n              # we do a similar check later on, but it needs to be here too\n              # for edge case 1.5: an existing commit pushed to a new branch\n              if [[ $COMMIT_FROM_JOB_NUM == $CIRCLE_SHA1 ]]; then\n                JOB_NUM=$(( $JOB_NUM - 1 ))\n                continue\n              fi\n\n              cd ~/project\n\n              # check if commit from JOB_NUM is an ancestor of $CIRCLE_SHA1\n              git merge-base --is-ancestor $COMMIT_FROM_JOB_NUM $CIRCLE_SHA1 || { RETURN_CODE=$?; }\n\n              if [[ $RETURN_CODE == 1 ]]; then\n                echo \"----------------------------------------------------------------------------------------------------\"\n                echo \"commit $COMMIT_FROM_JOB_NUM from job $JOB_NUM is not an ancestor of the current commit\"\n                echo \"----------------------------------------------------------------------------------------------------\"\n                JOB_NUM=$(( $JOB_NUM - 1 ))\n                continue\n              elif [[ $RETURN_CODE == \"\" ]]; then\n                echo \"----------------------------------------------------------------------------------------------------\"\n                echo \"commit $COMMIT_FROM_JOB_NUM from job $JOB_NUM is an ancestor of the current commit\"\n                echo \"----------------------------------------------------------------------------------------------------\"\n                FOUND_BASE_COMPARE_COMMIT=true\n                break\n              else\n                echo \"unknown return code $RETURN_CODE from git merge-base with base commit $COMMIT_FROM_JOB_NUM, from job $JOB_NUM\"\n                exit 1\n              fi\n            else\n              # if not a new branch, find its most recent previous commit\n\n              # by now, if none of conditions 1, 2/2.5, or 3 apply, we're done:\n              # 1. make sure job isn't part of the same workflow\n              if [[ ! $(grep \"\\\"workflow_id\\\" : \\\"$CIRCLE_WORKFLOW_ID\\\"\" JOB_OUTPUT) && \\\n                # 2. make sure job is not a retry of a previous job\n                $(grep '\"retry_of\" : null' JOB_OUTPUT) && \\\n                # 2.5 make sure job is not from a rerun workflow (same commit)\n                ! $(grep \"\\\"vcs_revision\\\" : \\\"$CIRCLE_SHA1\\\"\" JOB_OUTPUT) && \\\n                # make sure we are on the same branch as $CIRCLE_BRANCH\n                # (we've already ruled out that this is a brand-new branch)\n                $(grep \"\\\"branch\\\" : \\\"$CIRCLE_BRANCH\\\"\" JOB_OUTPUT) ]]; then\n\n                echo \"----------------------------------------------------------------------------------------------------\"\n                echo \"success! job $JOB_NUM was neither part of the current workflow, part of a rerun workflow, a retry of a previous job, nor from a different branch\"\n                echo \"----------------------------------------------------------------------------------------------------\"\n\n                FOUND_BASE_COMPARE_COMMIT=true\n              else\n                echo \"----------------------------------------------------------------------------------------------------\"\n                echo \"job $JOB_NUM was part of the current workflow, part of a rerun workflow, a retry of a previous job, or from a different branch\"\n                echo \"----------------------------------------------------------------------------------------------------\"\n                JOB_NUM=$(( $JOB_NUM - 1 ))\n                continue\n              fi\n            fi\n          done\n\n          ## CONCLUSION\n\n          # clean up\n          rm -f JOB_OUTPUT\n\n          BASE_COMPARE_COMMIT=$(extract_commit_from_job $VCS_TYPE $JOB_NUM)\n\n          # construct our compare URL, based on VCS type\n          if [[ $(echo $VCS_TYPE | grep github) ]]; then\n            CIRCLE_COMPARE_URL=\"https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/compare/${BASE_COMPARE_COMMIT:0:12}...${CIRCLE_SHA1:0:12}\"\n          else\n            CIRCLE_COMPARE_URL=\"https://bitbucket.org/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/branches/compare/${BASE_COMPARE_COMMIT:0:12}...${CIRCLE_SHA1:0:12}\"\n          fi\n\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"base compare commit hash is:\" $BASE_COMPARE_COMMIT\n          echo \"\"\n          echo $BASE_COMPARE_COMMIT > BASE_COMPARE_COMMIT.txt\n          echo \"this job's commit hash is:\" $CIRCLE_SHA1\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"recreated CIRCLE_COMPARE_URL:\"\n          echo $CIRCLE_COMPARE_URL\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"outputting CIRCLE_COMPARE_URL to a file in your working directory, called CIRCLE_COMPARE_URL.txt\"\n          echo \"(BASE_COMPARE_COMMIT has also been stored in your working directory as BASE_COMPARE_COMMIT.txt)\"\n          echo $CIRCLE_COMPARE_URL > CIRCLE_COMPARE_URL.txt\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"next: both CIRCLE_COMPARE_URL.txt and BASE_COMPARE_COMMIT.txt will be persisted to a workspace, in case they are needed in later jobs\"\n        name: Reconstruct CIRCLE_COMPARE_URL\n        when: always\n    - persist_to_workspace:\n        paths:\n        - CIRCLE_COMPARE_URL.txt\n        - BASE_COMPARE_COMMIT.txt\n        root: .\n    - run:\n        command: |+\n          # save value stored in file to a local env var\n          CIRCLE_COMPARE_URL=$(cat CIRCLE_COMPARE_URL.txt)\n\n          COMMIT_RANGE=$(echo $CIRCLE_COMPARE_URL | sed 's:^.*/compare/::g')\n\n          echo \"Commit range: $COMMIT_RANGE\"\n\n          # never publish a major release for now, let's come up with a better automated approach to major releases (or only do it manually)\n\n          # publish a minor release if there are new jobs or commands\n          if [[ $(git diff $COMMIT_RANGE --name-status | \\\n            grep -e \"A      src/commands\" -e \"A      src/jobs\") ]]; then\n            INTEGRATION_TAG=master-minor-$CIRCLE_BRANCH-${CIRCLE_SHA1:0:7}\n\n          # patch release if any changes to jobs, commands, examples, executors, @orb.yml\n          elif [[ $(git diff $COMMIT_RANGE --name-status | \\\n            grep -e \"src/commands\" -e \"src/jobs\" -e \"src/examples\" -e \"src/executors\" -e \"src/@orb.yml\") ]]; then\n            INTEGRATION_TAG=master-patch-$CIRCLE_BRANCH-${CIRCLE_SHA1:0:7}\n\n          # otherwise, don't publish a release\n          else\n            INTEGRATION_TAG=master-skip-$CIRCLE_BRANCH-${CIRCLE_SHA1:0:7}\n          fi\n\n          git tag $INTEGRATION_TAG\n          git push origin $INTEGRATION_TAG\n\n        name: construct/push git integration tag\n    - run:\n        command: |\n          # delete local tags\n          git tag -d $(git tag -l \"integration*\")\n\n          # fetch remote tags\n          git fetch\n\n          # delete remote tag\n          git push origin --delete $(git tag -l git tag -l \"integration*\") || true\n        name: cleanup old remote tags\n  orb-tools/publish-dev:\n    docker:\n    - image: circleci/circleci-cli:latest\n    steps:\n    - attach_workspace:\n        at: workspace\n    - run:\n        command: \"circleci orb publish workspace/orb.yml circleci/sumologic@dev:alpha\\\n          \\ --token $CIRCLE_TOKEN \\n\"\n        name: |\n          Publish orb at workspace/orb.yml to circleci/sumologic@dev:alpha NOTE: this currently assumes you are publishing to the registry at circleci.com\n    - run:\n        command: \"circleci orb publish workspace/orb.yml circleci/sumologic@dev:${CIRCLE_SHA1:0:7}\\\n          \\ --token $CIRCLE_TOKEN \\n\"\n        name: |\n          Publish orb at workspace/orb.yml to circleci/sumologic@dev:${CIRCLE_SHA1:0:7} NOTE: this currently assumes you are publishing to the registry at circleci.com\n    - store_artifacts:\n        path: workspace/orb.yml\n  emulate-dev_2:\n    docker:\n    - image: cimg/node\n    steps:\n    - run:\n        command: echo \"This job serves to emulate a job in a workflow that takes some\n          amount of time to complete.\"\n    - run:\n        command: sleep 50\n  orb-tools/lint:\n    docker:\n    - image: singapore/lint-condo\n    resource_class: small\n    steps:\n    - checkout\n    - run:\n        command: |\n          touch .yamllint || true\n          cat << EOF > .yamllint\n          extends: relaxed\n\n          rules:\n            line-length:\n              max: 200\n              allow-non-breakable-inline-mappings: true\n\n          EOF\n        name: output default .yamllint file in the working directory\n    - run:\n        command: |\n          yamllint .\n        name: yamllint\n  workflow-collector-dev:\n    docker:\n    - image: cimg/base\n    resource_class: small\n    steps:\n    - run:\n        command: |\n          if [[ $EUID == 0 ]]; then export SUDO=\"\"; else export SUDO=\"sudo\"; fi\n\n          # grab jq version\n          if [[ latest == \"latest\" ]]; then\n            # extract latest version from GitHub releases API\n            JQ_VERSION_STRING=$(curl --silent --show-error --location --fail --retry 3 \\\n              https://api.github.com/repos/stedolan/jq/releases/latest | grep tag_name | sed -E 's/\"/%/g')\n\n            IFS='%'; arrJQ_VERSION=($JQ_VERSION_STRING); unset IFS\n\n            JQ_VERSION=${arrJQ_VERSION[3]}\n\n            echo \"Latest version of jq is $JQ_VERSION\"\n          else\n            JQ_VERSION=latest\n          fi\n\n          # check if jq needs to be installed\n          if command -v jq >> /dev/null 2>&1; then\n            if jq --version | grep $JQ_VERSION >> /dev/null 2>&1; then\n              echo \"$JQ_VERSION is already installed\"\n              exit 0\n            else\n              echo \"A different version of jq is installed ($(jq --version)); removing it\"\n              $SUDO rm -f $(command -v jq)\n            fi\n          fi\n\n          # get source download URL for specified version\n          if [[ $(curl --silent --show-error --location --fail --retry 3 \\\n            \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n            grep browser_download_url | grep -o -e 'https.*tar.gz') ]]; then\n\n            JQ_SOURCE_URL=$(curl --silent --show-error --location --fail --retry 3 \\\n            \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n            grep browser_download_url | grep -o -e 'https.*tar.gz')\n          else\n            JQ_SOURCE_URL=\"https://github.com/stedolan/jq/archive/$JQ_VERSION.tar.gz\"\n          fi\n\n          # download jq\n          curl -O --silent --show-error --location --fail --retry 3 \\\n            \"$JQ_SOURCE_URL\"\n\n          tar xf \"$JQ_VERSION.tar.gz\" && rm -rf \"$JQ_VERSION.tar.gz\"\n\n          # extract version number\n          JQ_VERSION_NUMBER_STRING=$(echo $JQ_VERSION | sed -E 's/-/ /')\n\n          arrJQ_VERSION_NUMBER=($JQ_VERSION_NUMBER_STRING)\n\n          JQ_VERSION_NUMBER=\"${arrJQ_VERSION_NUMBER[1]}\"\n\n          # get binary download URL for specified version\n          # handle mac version\n          if uname -a | grep Darwin > /dev/null 2>&1; then\n            JQ_BINARY_URL=$(curl --silent --show-error --location --fail --retry 3 \\\n              \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n              grep browser_download_url | grep '/jq-osx.*64.*\"' | \\\n              grep -o -e 'https.*jq-osx.*64.*' | sed -E 's%\"%%g')\n          else\n            # linux version\n            JQ_BINARY_URL=$(curl --silent --show-error --location --fail --retry 3 \\\n              \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n              grep browser_download_url | grep '/jq-linux.*64.*\"' | \\\n              grep -o -e 'https.*jq-linux.*64.*' | sed -E 's%\"%%g')\n          fi\n\n          if [ -d \"$JQ_VERSION/sig\" ]; then\n            # import jq sigs\n\n            if uname -a | grep Darwin > /dev/null 2>&1; then\n              HOMEBREW_NO_AUTO_UPDATE=1 brew install gnupg coreutils\n\n              PLATFORM=osx-amd64\n            else\n              if cat /etc/issue | grep Alpine > /dev/null 2>&1; then\n                $SUDO apk add gnupg > /dev/null 2>&1\n              fi\n              PLATFORM=linux64\n            fi\n\n            gpg --import \"$JQ_VERSION/sig/jq-release.key\" > /dev/null\n\n            curl --output \"$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM\" \\\n                --silent --show-error --location --fail --retry 3 \\\n                \"$JQ_BINARY_URL\"\n\n            # verify sha256sum, sig, install\n\n            gpg --verify \"$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM.asc\"\n\n            cd \"$JQ_VERSION/sig/v$JQ_VERSION_NUMBER\" && grep \"jq-$PLATFORM\" \"sha256sum.txt\" | \\\n            sha256sum -c -\n\n          else\n            curl --output \"jq-$PLATFORM\" \\\n              --silent --show-error --location --fail --retry 3 \\\n              \"$JQ_BINARY_URL\"\n          fi\n\n          $SUDO mv \"jq-$PLATFORM\" /usr/local/bin/jq\n          $SUDO chmod +x /usr/local/bin/jq\n\n          # verify version\n          echo \"jq has been installed to $(which jq)\"\n          echo \"jq version:\"\n          echo \"$(jq --version)\"\n        name: Install jq\n    - run:\n        command: |\n          ###############\n          # Begin Collecting\n          ###############\n          DATA_URL=\"https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/jobs?circle-token=$CIRCLE_TOKEN\"\n          WF_DATA=$(curl -s \"$DATA_URL\" | jq '.items')\n          WF_LENGTH=$(echo \"$WF_DATA\" | jq length)\n          # GET URL PATH DATA\n          VCS_SHORT=$(echo $CIRCLE_BUILD_URL | cut -d\"/\" -f4)\n          case $VCS_SHORT in\n            gh)\n              VCS=github\n              ;;\n            bb)\n              VCS=bitbucket\n              ;;\n            *)\n              echo \"No VCS found. Error\" && exit 1\n              ;;\n          esac\n          # Assume the WF is currently running\n          WF_FINISHED=false\n          echo \"Jobs in Workflow: $WF_LENGTH\"\n          echo\n          # Exit if no other jobs in the Workflow.\n          if [ \"$WF_LENGTH\" -lt 2 ];\n          then\n            echo \"Only a single job has been found in the workflow, indicating this reporter is the only job in the pipeline.\"\n            echo \"Please add other jobs to the Workflow you wish to collect data on to send to Sumologic\"\n            exit 1\n          fi\n          #####################\n          ## START MAIN LOOP ##\n          #####################\n          # Check the status of all jobs in the workflow that are not this job and wait until they have all finished.\n          while [ \"$WF_FINISHED\" = false ]\n          do\n            WF_DATA=$(curl -s \"$DATA_URL\" | jq '.items')\n            #debug\n            echo \"DEBUG\"\n            echo $WF_DATA\n            echo \"Waiting for other jobs to finish...\"\n            #####\n            # Send Workflow Data to SumoLogic\n            #####\n            mkdir -p /tmp/sumologic-logs/\n            WF_SL_PAYLOAD=$(curl -s \"$DATA_URL\" | jq '.')\n            echo $WF_SL_PAYLOAD > /tmp/sumologic-logs/workflow-collector.json\n            curl -s -X POST -T /tmp/sumologic-logs/workflow-collector.json $WORKFLOW_HTTP_SOURCE\n            # for each job in the workflow fetch the status.\n            # the WF_FINISHED will be assumed true unless one of the jobs in the Workflow is still running\n            # the flag will then be set back to false.\n            WF_FINISHED=true\n            i=\"0\"\n            ################\n            ### JOB LOOP ###\n            ################\n            while [ $i -lt \"$WF_LENGTH\" ]\n            do\n              echo \"looping: $i\"\n              # fetch the job info\n              JOB_DATA=$(echo \"$WF_DATA\" | jq --arg i \"$i\" \".[$i]\")\n              #debug\n              echo \"DEBUG\"\n              echo $JOB_DATA\n              JOB_NUMBER=$(echo \"$JOB_DATA\" | jq \".job_number\")\n              JOB_STATUS=$(echo \"$JOB_DATA\" | jq \".status\")\n              JOB_NAME=$(echo \"$JOB_DATA\" | jq \".name\")\n              # Only check the job if it is not this current job\n              if [ \"$JOB_NUMBER\" = \"$CIRCLE_BUILD_NUM\" ];\n              then\n                echo \"This is the reporter job. Skipping\"\n              else\n                # If this job is NOT the current job, check the status\n                echo \"JOB: $JOB_NAME\"\n                echo \"JOB NUM: $JOB_NUMBER\"\n                echo \"STATUS: $JOB_STATUS\"\n                #####\n                # Send Job Data to SumoLogic\n                #####\n                mkdir -p /tmp/sumologic-logs/\n                ###\n                # Process Job api 1.1 Data\n                ###\n                echo\n                echo JOB DATA URL\n                echo \"https://circleci.com/api/v1.1/project/$VCS/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUMBER?circle-token=\"\n                # JOB_DATA_RAW=$(curl -s \"https://circleci.com/api/v1.1/project/$VCS/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUMBER?circle-token=$CIRCLE_TOKEN\")\n                echo $JOB_DATA_RAW > /tmp/sumologic-logs/job-collector.json\n                curl -s -X POST -T /tmp/sumologic-logs/job-collector.json $JOB_HTTP_SOURCE\n                ###\n                if [ \"$JOB_STATUS\" != '\"running\"' ];\n                then\n                  echo \"Job $CIRCLE_JOB $JOB_NUMBER is complete - $JOB_STATUS\"\n                else\n                  # If it is still running, then mark WF_FINISHED as false.\n                  WF_FINISHED=false\n                  echo \"Setting status of WF_FINISHED to false\"\n                fi\n              fi\n              echo \"rerunning loop\"\n              i=\"$((i+1))\"\n              echo \"increment loop to $i\"\n              echo \" ---------- \"\n              echo\n            done\n            echo \"Waiting 10 seconds\"\n            sleep 10\n          done\n          echo\n          ################\n          # WF COMPLETE  #\n          ################\n          echo\n          echo \"-------------------------------\"\n          echo \"All jobs in Workflow complete.\"\n          echo \"Sending final report.\"\n          echo \"-------------------------------\"\n          echo\n          echo\n          ########################################\n          # Send end-of-workflow data to Sumologic\n          ########################################\n          WF_SL_PAYLOAD=$(curl -s \"$DATA_URL\" | jq '.')\n          # debug\n          echo \"debug\"\n          echo \"SENDING FINAL WORKFLOW DATA\"\n          echo $WF_SL_PAYLOAD\n          echo $WF_SL_PAYLOAD > /tmp/sumologic-logs/workflow-collector.json\n          curl -s -X POST -T /tmp/sumologic-logs/workflow-collector.json $WORKFLOW_HTTP_SOURCE\n          ########################################\n          # Send end-of-workflow jobs data to Sumologic\n          ########################################\n          echo \"SENDING FINAL JOB INFORMATION\"\n          i=0\n          while [ $i -lt \"$WF_LENGTH\" ]\n            do\n              echo \"looping: $i\"\n              # fetch the job info\n              JOB_DATA=$(echo \"$WF_DATA\" | jq --arg i \"$i\" \".[$i]\")\n              JOB_NUMBER=$(echo \"$JOB_DATA\" | jq \".job_number\")\n              JOB_STATUS=$(echo \"$JOB_DATA\" | jq \".status\")\n              JOB_NAME=$(echo \"$JOB_DATA\" | jq \".name\")\n              # Only check the job if it is not this current job\n              if [ \"$JOB_NUMBER\" = \"$CIRCLE_BUILD_NUM\" ];\n              then\n                echo \"This is the reporter job. Skipping\"\n              else\n                # If this job is NOT the current job, check the status\n                echo \"JOB: $JOB_NAME\"\n                echo \"JOB NUM: $JOB_NUMBER\"\n                echo \"STATUS: $JOB_STATUS\"\n                #####\n                # Send Job Data to SumoLogic\n                #####\n                mkdir -p /tmp/sumologic-logs/\n                ###\n                # Process Job api 1.1 Data\n                ###\n                JOB_DATA_RAW=$(curl -s \"https://circleci.com/api/v1.1/project/$VCS/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUMBER?circle-token=$CIRCLE_TOKEN\")\n                # debug\n                echo debug\n                echo \"---\"\n                echo\n                echo \"SHOW JOB DATA\"\n                echo\n                echo \"---\"\n                echo $JOB_DATA_RAW\n                echo $JOB_DATA_RAW > /tmp/sumologic-logs/job-collector.json\n                curl -s -X POST -T /tmp/sumologic-logs/job-collector.json $JOB_HTTP_SOURCE\n                ###\n              fi\n              echo \"rerunning loop\"\n              i=\"$((i+1))\"\n              echo \"increment loop to $i\"\n              echo \" ---------- \"\n              echo\n            done\n        name: Workflow Collector\n  trigger-integration-dev:\n    docker:\n    - image: cibuilds/base\n    resource_class: small\n    steps:\n    - checkout\n    - add_ssh_keys:\n        fingerprints:\n        - 97:c9:c2:9e:1b:04:ee:ee:99:4d:6b:f7:ce:e0:00:78\n    - run:\n        command: |\n          git config --global user.email \"$CIRCLE_USERNAME@users.noreply.github.com\"\n          git config --global user.name \"$CIRCLE_USERNAME\"\n        name: git config\n    - run:\n        command: \"if [[ -z \\\"${CIRCLE_TOKEN}\\\" ]]; then\\n  echo \\\"ERROR: Missing environment\\\n          \\ variable CIRCLE_TOKEN\\\" >&2\\n  if [[ -n \\\"You have not stored a CircleCI\\\n          \\ API token. If this is a private repository, the next step will fail.\\n\\\n          \\\" ]]; then\\n    echo \\\"You have not stored a CircleCI API token. If this\\\n          \\ is a private repository, the next step will fail.\\n\\\" >&2\\n  fi\\n  \\n\\\n          else\\n  echo \\\"Yes, CIRCLE_TOKEN is defined!\\\"\\nfi\\n\"\n        name: Checking if $CIRCLE_TOKEN is defined...\n    - run:\n        command: |\n          ## VARS\n\n          # this starts as false, set to true to exit `until` loop\n          FOUND_BASE_COMPARE_COMMIT=false\n\n          # start iteration from the job before $CIRCLE_BUILD_NUM\n          JOB_NUM=$(( $CIRCLE_BUILD_NUM - 1 ))\n\n          ## UTILS\n\n          extract_commit_from_job () {\n            # abstract this logic out, it gets reused a few times\n            # takes $1 (VCS_TYPE) & $2 (a job number)\n\n            curl --user $CIRCLE_TOKEN: \\\n              https://circleci.com/api/v1.1/project/$1/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$2 | \\\n              grep '\"vcs_revision\" : ' | sed -E 's/\"vcs_revision\" ://' | sed -E 's/[[:punct:]]//g' | sed -E 's/ //g'\n          }\n\n          check_if_branch_is_new () {\n            # takes a single argument for VCS_TYPE\n            # functionally, 'new' means: same commit for all jobs on the branch\n\n            # assume this is true, set to false if proven otherwise\n            local BRANCH_IS_NEW=true\n\n            # grab URL endpoints for jobs on this branch\n            # transform them into single-job API endpoints\n            # output them to a file for subsequent iteration\n            curl --user $CIRCLE_TOKEN: \\\n              https://circleci.com/api/v1.1/project/$1/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/tree/$CIRCLE_BRANCH?limit=100 | \\\n              grep \"\\\"build_url\\\" : \\\"http\" | sed -E 's/\"build_url\" : //' | \\\n              sed -E 's|/bb/|/api/v1.1/project/bitbucket/|' | \\\n              sed -E 's|/gh/|/api/v1.1/project/github/|' | \\\n              sed -E 's/\"|,//g' | sed -E 's/ //g' \\\n              > API_ENDPOINTS_FOR_JOBS_ON_BRANCH\n\n            # loop through each job to compare commit hashes\n            while read line\n            do\n              if [[ $(curl --user $CIRCLE_TOKEN: $line | grep \"\\\"vcs_revision\\\" : \\\"$CIRCLE_SHA1\\\"\") ]]; then\n                continue\n              else\n                BRANCH_IS_NEW=false\n                break\n              fi\n            done < API_ENDPOINTS_FOR_JOBS_ON_BRANCH\n\n            # clean up\n            if [[ false == false ]]; then\n              rm -f API_ENDPOINTS_FOR_JOBS_ON_BRANCH\n            fi\n\n            # true or false\n            echo $BRANCH_IS_NEW\n          }\n\n          ## SETUP\n\n          # determine VCS type, so we don't worry about it later\n          if [[ $(echo $CIRCLE_REPOSITORY_URL | grep github.com:$CIRCLE_PROJECT_USERNAME) ]]; then\n            VCS_TYPE=github\n          else\n            VCS_TYPE=bitbucket\n          fi\n\n          # check if this is a new branch, as that informs later steps\n          echo \"checking if $CIRCLE_BRANCH is a new branch...\"\n          echo \"----------------------------------------------------------------------------------------------------\"\n          if [[ $(check_if_branch_is_new $VCS_TYPE) == true ]]; then\n            echo \"----------------------------------------------------------------------------------------------------\"\n            echo \"yes, $CIRCLE_BRANCH is new and $CIRCLE_SHA1 is its only commit\"\n            echo \"finding most recent ancestor commit from any other branch...\"\n            echo \"----------------------------------------------------------------------------------------------------\"\n            BRANCH_IS_NEW=true\n          else\n            echo \"----------------------------------------------------------------------------------------------------\"\n            echo \"$CIRCLE_BRANCH is not a new branch, searching for its most recent previous commit...\"\n            echo \"----------------------------------------------------------------------------------------------------\"\n            BRANCH_IS_NEW=false\n          fi\n\n          ## EXECUTION\n\n          # manually iterate through previous jobs\n          until [[ $FOUND_BASE_COMPARE_COMMIT == true ]]\n          do\n\n            # save circle api output to a temp file for reuse\n            curl --user $CIRCLE_TOKEN: \\\n              https://circleci.com/api/v1.1/project/$VCS_TYPE/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUM \\\n              > JOB_OUTPUT\n\n            # general approach:\n            # there's a couple of skip conditions to observe here—\n            # roughly in order of precedence:\n\n            # 1. is JOB_NUM part of the current workflow?\n            # 2. is JOB_NUM a retry of a job from the same commit?\n              # 2.5 or part of a rerun workflow from the same commit?\n            # 3. is JOB_NUM from a different branch?\n              # 3.5 unless this is a new branch—see below\n\n            # edge cases:\n            # 1. if $CIRCLE_SHA1 is the first commit on a new branch\n              # then we need the most recent ancestor, branch-agnostic\n              # 1.5 a new branch doesn't always mean a new commit\n\n            # handling condition 3 & edge case 1:\n            # check if this is a brand-new branch\n            if [[ $BRANCH_IS_NEW == true ]]; then\n              COMMIT_FROM_JOB_NUM=$(extract_commit_from_job $VCS_TYPE $JOB_NUM)\n\n              # we do a similar check later on, but it needs to be here too\n              # for edge case 1.5: an existing commit pushed to a new branch\n              if [[ $COMMIT_FROM_JOB_NUM == $CIRCLE_SHA1 ]]; then\n                JOB_NUM=$(( $JOB_NUM - 1 ))\n                continue\n              fi\n\n              cd ~/project\n\n              # check if commit from JOB_NUM is an ancestor of $CIRCLE_SHA1\n              git merge-base --is-ancestor $COMMIT_FROM_JOB_NUM $CIRCLE_SHA1 || { RETURN_CODE=$?; }\n\n              if [[ $RETURN_CODE == 1 ]]; then\n                echo \"----------------------------------------------------------------------------------------------------\"\n                echo \"commit $COMMIT_FROM_JOB_NUM frpe\n          if [[ $(echo $VCS_TYPE | grep github) ]]; then\n            CIRCLE_COMPARE_URL=\"https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/compare/${BASE_COMPARE_COMMIT:0:12}...${CIRCLE_SHA1:0:12}\"\n          else\n            CIRCLE_COMPARE_URL=\"https://bitbucket.org/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/branches/compare/${BASE_COMPARE_COMMIT:0:12}...${CIRCLE_SHA1:0:12}\"\n          fi\n\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"base compare commit hash is:\" $BASE_COMPARE_COMMIT\n          echo \"\"\n          echo $BASE_COMPARE_COMMIT > BASE_COMPARE_COMMIT.txt\n          echo \"this job's commit hash is:\" $CIRCLE_SHA1\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"recreated CIRCLE_COMPARE_URL:\"\n          echo $CIRCLE_COMPARE_URL\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"outputting CIRCLE_COMPARE_URL to a file in your working directory, called CIRCLE_COMPARE_URL.txt\"\n          echo \"(BASE_COMPARE_COMMIT has also been stored in your working directory as BASE_COMPARE_COMMIT.txt)\"\n          echo $CIRCLE_COMPARE_URL > CIRCLE_COMPARE_URL.txt\n          echo \"----------------------------------------------------------------------------------------------------\"\n          echo \"next: both CIRCLE_COMPARE_URL.txt and BASE_COMPARE_COMMIT.txt will be persisted to a workspace, in case they are needed in later jobs\"\n        name: Reconstruct CIRCLE_COMPARE_URL\n        when: always\n    - persist_to_workspace:\n        paths:\n        - CIRCLE_COMPARE_URL.txt\n        - BASE_COMPARE_COMMIT.txt\n        root: .\n    - run:\n        command: |+\n          # save value stored in file to a local env var\n          CIRCLE_COMPARE_URL=$(cat CIRCLE_COMPARE_URL.txt)\n\n          COMMIT_RANGE=$(echo $CIRCLE_COMPARE_URL | sed 's:^.*/compare/::g')\n\n          echo \"Commit range: $COMMIT_RANGE\"\n\n          # never publish a major release for now, let's come up with a better automated approach to major releases (or only do it manually)\n\n          # publish a minor release if there are new jobs or commands\n          if [[ $(git diff $COMMIT_RANGE --name-status | \\\n            grep -e \"A      src/commands\" -e \"A      src/jobs\") ]]; then\n            INTEGRATION_TAG=integration-minor-$CIRCLE_BRANCH-${CIRCLE_SHA1:0:7}\n\n          # patch release if any changes to jobs, commands, examples, executors, @orb.yml\n          elif [[ $(git diff $COMMIT_RANGE --name-status | \\\n            grep -e \"src/commands\" -e \"src/jobs\" -e \"src/examples\" -e \"src/executors\" -e \"src/@orb.yml\") ]]; then\n            INTEGRATION_TAG=integration-patch-$CIRCLE_BRANCH-${CIRCLE_SHA1:0:7}\n\n          # otherwise, don't publish a release\n          else\n            INTEGRATION_TAG=integration-skip-$CIRCLE_BRANCH-${CIRCLE_SHA1:0:7}\n          fi\n\n          git tag $INTEGRATION_TAG\n          git push origin $INTEGRATION_TAG\n\n        name: construct/push git integration tag\n  workflow-collector-master:\n    docker:\n    - image: cimg/base\n    resource_class: small\n    steps:\n    - run:\n        command: |\n          if [[ $EUID == 0 ]]; then export SUDO=\"\"; else export SUDO=\"sudo\"; fi\n\n          # grab jq version\n          if [[ latest == \"latest\" ]]; then\n            # extract latest version from GitHub releases API\n            JQ_VERSION_STRING=$(curl --silent --show-error --location --fail --retry 3 \\\n              https://api.github.com/repos/stedolan/jq/releases/latest | grep tag_name | sed -E 's/\"/%/g')\n\n            IFS='%'; arrJQ_VERSION=($JQ_VERSION_STRING); unset IFS\n\n            JQ_VERSION=${arrJQ_VERSION[3]}\n\n            echo \"Latest version of jq is $JQ_VERSION\"\n          else\n            JQ_VERSION=latest\n          fi\n\n          # check if jq needs to be installed\n          if command -v jq >> /dev/null 2>&1; then\n            if jq --version | grep $JQ_VERSION >> /dev/null 2>&1; then\n              echo \"$JQ_VERSION is already installed\"\n              exit 0\n            else\n              echo \"A different version of jq is installed ($(jq --version)); removing it\"\n              $SUDO rm -f $(command -v jq)\n            fi\n          fi\n\n          # get source download URL for specified version\n          if [[ $(curl --silent --show-error --location --fail --retry 3 \\\n            \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n            grep browser_download_url | grep -o -e 'https.*tar.gz') ]]; then\n\n            JQ_SOURCE_URL=$(curl --silent --show-error --location --fail --retry 3 \\\n            \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n            grep browser_download_url | grep -o -e 'https.*tar.gz')\n          else\n            JQ_SOURCE_URL=\"https://github.com/stedolan/jq/archive/$JQ_VERSION.tar.gz\"\n          fi\n\n          # download jq\n          curl -O --silent --show-error --location --fail --retry 3 \\\n            \"$JQ_SOURCE_URL\"\n\n          tar xf \"$JQ_VERSION.tar.gz\" && rm -rf \"$JQ_VERSION.tar.gz\"\n\n          # extract version number\n          JQ_VERSION_NUMBER_STRING=$(echo $JQ_VERSION | sed -E 's/-/ /')\n\n          arrJQ_VERSION_NUMBER=($JQ_VERSION_NUMBER_STRING)\n\n          JQ_VERSION_NUMBER=\"${arrJQ_VERSION_NUMBER[1]}\"\n\n          # get binary download URL for specified version\n          # handle mac version\n          if uname -a | grep Darwin > /dev/null 2>&1; then\n            JQ_BINARY_URL=$(curl --silent --show-error --location --fail --retry 3 \\\n              \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n              grep browser_download_url | grep '/jq-osx.*64.*\"' | \\\n              grep -o -e 'https.*jq-osx.*64.*' | sed -E 's%\"%%g')\n          else\n            # linux version\n            JQ_BINARY_URL=$(curl --silent --show-error --location --fail --retry 3 \\\n              \"https://api.github.com/repos/stedolan/jq/releases/tags/$JQ_VERSION\" | \\\n              grep browser_download_url | grep '/jq-linux.*64.*\"' | \\\n              grep -o -e 'https.*jq-linux.*64.*' | sed -E 's%\"%%g')\n          fi\n\n          if [ -d \"$JQ_VERSION/sig\" ]; then\n            # import jq sigs\n\n            if uname -a | grep Darwin > /dev/null 2>&1; then\n              HOMEBREW_NO_AUTO_UPDATE=1 brew install gnupg coreutils\n\n              PLATFORM=osx-amd64\n            else\n              if cat /etc/issue | grep Alpine > /dev/null 2>&1; then\n                $SUDO apk add gnupg > /dev/null 2>&1\n              fi\n              PLATFORM=linux64\n            fi\n\n            gpg --import \"$JQ_VERSION/sig/jq-release.key\" > /dev/null\n\n            curl --output \"$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM\" \\\n                --silent --show-error --location --fail --retry 3 \\\n                \"$JQ_BINARY_URL\"\n\n            # verify sha256sum, sig, install\n\n            gpg --verify \"$JQ_VERSION/sig/v$JQ_VERSION_NUMBER/jq-$PLATFORM.asc\"\n\n            cd \"$JQ_VERSION/sig/v$JQ_VERSION_NUMBER\" && grep \"jq-$PLATFORM\" \"sha256sum.txt\" | \\\n            sha256sum -c -\n\n          else\n            curl --output \"jq-$PLATFORM\" \\\n              --silent --show-error --location --fail --retry 3 \\\n              \"$JQ_BINARY_URL\"\n          fi\n\n          $SUDO mv \"jq-$PLATFORM\" /usr/local/bin/jq\n          $SUDO chmod +x /usr/local/bin/jq\n\n          # verify version\n          echo \"jq has been installed to $(which jq)\"\n          echo \"jq version:\"\n          echo \"$(jq --version)\"\n        name: Install jq\n    - run:\n        command: |\n          ###############\n          # Begin Collecting\n          ###############\n          DATA_URL=\"https://circleci.com/api/v2/workflow/$CIRCLE_WORKFLOW_ID/jobs?circle-token=$CIRCLE_TOKEN\"\n          WF_DATA=$(curl -s \"$DATA_URL\" | jq '.items')\n          WF_LENGTH=$(echo \"$WF_DATA\" | jq length)\n          # GET URL PATH DATA\n          VCS_SHORT=$(echo $CIRCLE_BUILD_URL | cut -d\"/\" -f4)\n          case $VCS_SHORT in\n            gh)\n              VCS=github\n              ;;\n            bb)\n              VCS=bitbucket\n              ;;\n            *)\n              echo \"No VCS found. Error\" && exit 1\n              ;;\n          esac\n          # Assume the WF is currently running\n          WF_FINISHED=false\n          echo \"Jobs in Workflow: $WF_LENGTH\"\n          echo\n          # Exit if no other jobs in the Workflow.\n          if [ \"$WF_LENGTH\" -lt 2 ];\n          then\n            echo \"Only a single job has been found in the workflow, indicating this reporter is the only job in the pipeline.\"\n            echo \"Please add other jobs to the Workflow you wish to collect data on to send to Sumologic\"\n            exit 1\n          fi\n          #####################\n          ## START MAIN LOOP ##\n          #####################\n          # Check the status of all jobs in the workflow that are not this job and wait until they have all finished.\n          while [ \"$WF_FINISHED\" = false ]\n          do\n            WF_DATA=$(curl -s \"$DATA_URL\" | jq '.items')\n            #debug\n            echo \"DEBUG\"\n            echo $WF_DATA\n            echo \"Waiting for other jobs to finish...\"\n            #####\n            # Send Workflow Data to SumoLogic\n            #####\n            mkdir -p /tmp/sumologic-logs/\n            WF_SL_PAYLOAD=$(curl -s \"$DATA_URL\" | jq '.')\n            echo $WF_SL_PAYLOAD > /tmp/sumologic-logs/workflow-collector.json\n            curl -s -X POST -T /tmp/sumologic-logs/workflow-collector.json $WORKFLOW_HTTP_SOURCE\n            # for each job in the workflow fetch the status.\n            # the WF_FINISHED will be assumed true unless one of the jobs in the Workflow is still running\n            # the flag will then be set back to false.\n            WF_FINISHED=true\n            i=\"0\"\n            ################\n            ### JOB LOOP ###\n            ################\n            echo $WF_SL_PAYLOAD > /tmp/sumologic-logs/workflow-collector.json\n          curl -s -X POST -T /tmp/sumologic-logs/workflow-collector.json $WORKFLOW_HTTP_SOURCE\n          ########################################\n          # Send end-of-workflow jobs data to Sumologic\n          ########################################\n          echo \"SENDING FINAL JOB INFORMATION\"\n          i=0\n          while [ $i -lt \"$WF_LENGTH\" ]\n            do\n              echo \"looping: $i\"\n              # fetch the job info\n              JOB_DATA=$(echo \"$WF_DATA\" | jq --arg i \"$i\" \".[$i]\")\n              JOB_NUMBER=$(echo \"$JOB_DATA\" | jq \".job_number\")\n              JOB_STATUS=$(echo \"$JOB_DATA\" | jq \".status\")\n              JOB_NAME=$(echo \"$JOB_DATA\" | jq \".name\")\n              # Only check the job if it is not this current job\n              if [ \"$JOB_NUMBER\" = \"$CIRCLE_BUILD_NUM\" ];\n              then\n                echo \"This is the reporter job. Skipping\"\n              else\n                # If this job is NOT the current job, check the status\n                echo \"JOB: $JOB_NAME\"\n                echo \"JOB NUM: $JOB_NUMBER\"\n                echo \"STATUS: $JOB_STATUS\"\n                #####\n                # Send Job Data to SumoLogic\n                #####\n                mkdir -p /tmp/sumologic-logs/\n                ###\n                # Process Job api 1.1 Data\n                ###\n                JOB_DATA_RAW=$(curl -s \"https://circleci.com/api/v1.1/project/$VCS/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUMBER?circle-token=$CIRCLE_TOKEN\")\n                # debug\n                echo debug\n                echo \"---\"\n                echo\n                echo \"SHOW JOB DATA\"\n                echo\n                echo \"---\"\n                echo $JOB_DATA_RAW\n                echo $JOB_DATA_RAW > /tmp/sumologic-logs/job-collector.json\n                curl -s -X POST -T /tmp/sumologic-logs/job-collector.json $JOB_HTTP_SOURCE\n                ###\n              fi\n              echo \"rerunning loop\"\n              i=\"$((i+1))\"\n              echo \"increment loop to $i\"\n              echo \" ---------- \"\n              echo\n            done\n        name: Workflow Collector\n  emulate-dev_1:\n    docker:\n    - image: cimg/node\n    steps:\n    - run:\n        command: echo \"This job serves to emulate a job in a workflow that takes some\n          amount of time to complete.\"\n    - run:\n        command: sleep 20\n  dev-promote-patch:\n    docker:\n    - image: circleci/circleci-cli:latest\n    steps:\n    - checkout\n    - run:\n        command: |\n          circleci orb publish promote \\\n            circleci/orb-tools@dev:${CIRCLE_SHA1:0:7} \\\n            patch --token \\\n            $CIRCLE_TOKEN\n\n          echo \"View this orb release in the orb registry:\"\n          echo \"https://circleci.com/orbs/registry/orb/circleci/orb-tools\"\n        name: promote dev orb to production/semantic release\n    - add_ssh_keys:\n        fingerprints:\n        - 97:c9:c2:9e:1b:04:ee:ee:99:4d:6b:f7:ce:e0:00:78\n    - run:\n        command: |\n          git config --global user.email \"$CIRCLE_USERNAME@users.noreply.github.com\"\n          git config --global user.name \"$CIRCLE_USERNAME\"\n\n          # construct/push new tag\n          NEW_VERSION=$(circleci orb info circleci/orb-tools | grep Latest | sed -E 's|Latest: circleci/orb-tools@||')\n\n          TAG=\"v$NEW_VERSION\"\n\n          git tag -a \"$TAG\" \\\n            -m \"patch\" \\\n            -m \"View this orb release in the orb registry:\" \\\n            -m \"https://circleci.com/orbs/registry/orb/circleci/orb-tools?version=$NEW_VERSION\" \\\n            -m \"View this orb release using the CircleCI CLI:\" \\\n            -m \"\\`circleci orb source circleci/orb-tools@$NEW_VERSION\\`\"\n\n          git push origin \"$TAG\"\n\n          # delete local tags\n          git tag -d $(git tag -l \"master*\")\n\n          # fetch remote tags\n          git fetch\n\n          # delete remote tag\n          git push origin --delete $(git tag -l git tag -l \"master*\") || true\n        name: git config\n  dev-promote-minor:\n    docker:\n    - image: circleci/circleci-cli:latest\n    steps:\n    - checkout\n    - run:\n        command: |\n          circleci orb publish promote \\\n            circleci/orb-tools@dev:${CIRCLE_SHA1:0:7} \\\n            minor --token \\\n            $CIRCLE_TOKEN\n\n          echo \"View this orb release in the orb registry:\"\n          echo \"https://circleci.com/orbs/registry/orb/circleci/orb-tools\"\n        name: promote dev orb to production/semantic release\n    - add_ssh_keys:\n        fingerprints:\n        - 97:c9:c2:9e:1b:04:ee:ee:99:4d:6b:f7:ce:e0:00:78\n    - run:\n        command: |\n          git config --global user.email \"$CIRCLE_USERNAME@users.noreply.github.com\"\n          git config --global user.name \"$CIRCLE_USERNAME\"\n\n          # construct/push new tag\n          NEW_VERSION=$(circleci orb info circleci/orb-tools | grep Latest | sed -E 's|Latest: circleci/orb-tools@||')\n\n          TAG=\"v$NEW_VERSION\"\n\n          git tag -a \"$TAG\" \\\n            -m \"minor\" \\\n            -m \"View this orb release in the orb registry:\" \\\n            -m \"https://circleci.com/orbs/registry/orb/circleci/orb-tools?version=$NEW_VERSION\" \\\n            -m \"View this orb release using the CircleCI CLI:\" \\\n            -m \"\\`circleci orb source circleci/orb-tools@$NEW_VERSION\\`\"\n\n          git push origin \"$TAG\"\n\n          # delete local tags\n          git tag -d $(git tag -l \"master*\")\n\n          # fetch remote tags\n          git fetch\n\n          # delete remote tag\n          git push origin --delete $(git tag -l git tag -l \"master*\") || true\n        name: git config\nworkflows:\n  lint-pack_validate_publish-dev:\n    jobs:\n    - orb-tools/lint\n    - orb-tools/pack:\n        requires:\n        - orb-tools/lint\n    - orb-tools/publish-dev:\n        requires:\n        - orb-tools/pack\n    - trigger-integration-dev:\n        filters:\n          branches:\n            ignore: master\n        requires:\n        - orb-tools/publish-dev\n    - trigger-integration-master:\n        filters:\n          branches:\n            only: master\n        requires:\n        - orb-tools/publish-dev\n  integration-tests_prod-release:\n    jobs:\n    - emulate-dev_1:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /integration-.*/\n    - emulate-master_1:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /master-.*/\n    - emulate-dev_2:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /integration-.*/\n    - emulate-master_2:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /master-.*/\n    - workflow-collector-dev:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /integration-.*/\n    - workflow-collector-master:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /master-.*/\n    - dev-promote-patch:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /master-patch.*/\n        requires:\n        - workflow-collector-master\n    - dev-promote-minor:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /master-minor.*/\n        requires:\n        - workflow-collector-master\n    - dev-promote-major:\n        filters:\n          branches:\n            ignore: /.*/\n          tags:\n            only: /master-major.*/\n        requires:\n        - workflow-collector-master\n  version: 2\n"
  },
  "messages" : [ ],
  "is_first_green_build" : false,
  "job_name" : null,
  "start_time" : "2019-09-04T13:25:04.972Z",
  "canceler" : null,
  "all_commit_details" : [ ],
  "platform" : "2.0",
  "outcome" : "success",
  "vcs_url" : "https://github.com/CircleCI-Public/sumologic-orb",
  "author_name" : null,
  "node" : null,
  "queued_at" : "2019-09-04T13:24:55.816Z",
  "canceled" : false,
  "author_email" : null
}
